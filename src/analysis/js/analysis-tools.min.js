var sensor,
  requestInfo = {},
  isDrawApogee = !1,
  isDrawPerigee = !1,
  isDrawInc = !1,
  isDrawEcc = !1,
  isDrawRAAN = !1,
  isDrawPeriod = !1,
  isDrawRng = !1,
  isDrawAz = !1,
  isDrawEl = !1,
  TAU = 2 * Math.PI,
  DEG2RAD = TAU / 360,
  RAD2DEG = 360 / TAU,
  minutesPerDay = 1440,
  millisecondsPerDay = 1.15741e-8,
  raeType = 3;
function loadJSON() {
  $.get(`sathist/${requestInfo.sat}.json`)
    .done(function (e) {
      drawChart(e);
    })
    .fail(function () {
      console.error('Could Not Load JSON File!');
    });
}
function drawChart(e) {
  var a = [],
    o = [],
    r = [],
    t = [],
    s = [],
    l = [],
    n = [],
    i = [],
    g = [],
    m = [],
    d = [],
    b = [];
  !(function () {
    for (var a, o = 0; o < e.length; o++)
      (a = satellite.twoline2satrec(e[o].TLE1, e[o].TLE2)),
        (extra = {}),
        (extra.year = e[o].TLE1.substr(18, 2)),
        (extra.jday = e[o].TLE1.substr(20, 12)),
        (extra.inclination = a.inclo * RAD2DEG),
        (extra.eccentricity = a.ecco),
        (extra.raan = a.nodeo * RAD2DEG),
        (extra.argPe = a.argpo * RAD2DEG),
        (extra.meanMotion = (60 * a.no * 24) / (2 * Math.PI)),
        (extra.semiMajorAxis = Math.pow(8681663.653 / extra.meanMotion, 2 / 3)),
        (extra.semiMinorAxis = extra.semiMajorAxis * Math.sqrt(1 - Math.pow(extra.eccentricity, 2))),
        (extra.apogee = extra.semiMajorAxis * (1 + extra.eccentricity) - 6371),
        (extra.perigee = extra.semiMajorAxis * (1 - extra.eccentricity) - 6371),
        (extra.period = 1440 / extra.meanMotion),
        (extra.TLE1 = e[o].TLE1),
        (extra.TLE2 = e[o].TLE2),
        (b[o] = extra);
  })(),
    (function () {
      if (void 0 === sensor) for (var c = 0; c < b.length; c++) a.push(`${b[c].year} ${b[c].jday}`);
      for (c = 0; c < b.length; c++) o.push({ x: c, y: b[c].inclination });
      for (c = 0; c < b.length; c++) r.push({ x: c, y: b[c].period });
      for (c = 0; c < b.length; c++) s.push({ x: c, y: b[c].perigee });
      for (c = 0; c < b.length; c++) t.push({ x: c, y: b[c].apogee });
      for (c = 0; c < b.length; c++) l.push({ x: c, y: b[c].raan });
      for (c = 0; c < b.length; c++) n.push({ x: c, y: b[c].eccentricity });
      if (void 0 !== sensor) {
        lookAngles = satellite.calculateLookAngles({ TLE1: e[e.length - 1].TLE1, TLE2: e[e.length - 1].TLE2 }, sensor, raeType);
        for (c = 0; c < lookAngles.length; c++)
          c > 0 && (Date.parse(lookAngles[c].time) - Date.parse(lookAngles[c - 1].time)) / 1e3 > satellite.lookanglesInterval
            ? (a.push('Gap'), i.push({ x: c, y: null }), g.push({ x: c, y: null }), m.push({ x: c, y: null }))
            : (a.push(`${lookAngles[c].time}`),
              lookAngles[c].rng > 0 && (lookAngles[c].rng = lookAngles[c].rng / 10),
              i.push({ x: c, y: lookAngles[c].rng }),
              sensor.obsminaz > sensor.obsmaxaz && lookAngles[c].az > sensor.obsmaxaz && sensor.obsminaz > 180 && (lookAngles[c].az = lookAngles[c].az - 360),
              g.push({ x: c, y: lookAngles[c].az }),
              m.push({ x: c, y: lookAngles[c].el }));
      }
      isDrawInc && d.push({ label: 'Inclination (deg)', data: o, backgroundColor: 'rgba(255, 20, 20, 0.8)', borderColor: 'rgba(255, 20, 20, 0.8)', borderWidth: 3, fill: !1 }),
        isDrawPerigee && d.push({ label: 'Perigee (km)', data: s, backgroundColor: 'rgba(20, 255, 20, 0.8)', borderColor: 'rgba(20, 255, 20, 0.8)', borderWidth: 1, fill: !1 }),
        isDrawApogee && d.push({ label: 'Apogee (km)', data: t, backgroundColor: 'rgba(20, 20, 255, 0.8)', borderColor: 'rgba(20, 20, 255, 0.8)', borderWidth: 1, fill: !1 }),
        isDrawPeriod && d.push({ label: 'Period (min)', data: r, backgroundColor: 'rgba(255, 20, 255, 0.8)', borderColor: 'rgba(255, 20, 255, 0.8)', borderWidth: 3, fill: !1 }),
        isDrawRAAN && d.push({ label: 'RAAN (deg)', data: l, backgroundColor: 'rgba(255, 100, 20, 0.8)', borderColor: 'rgba(255, 100, 20, 0.8)', borderWidth: 3, fill: !1 }),
        isDrawEcc && d.push({ label: 'Eccentricity', data: n, backgroundColor: 'rgba(100, 200, 255, 0.8)', borderColor: 'rgba(100, 200, 255, 0.8)', borderWidth: 3, fill: !1 }),
        isDrawRng && d.push({ label: 'Range (10 km)', data: i, backgroundColor: 'rgba(255, 200, 100, 0.8)', borderColor: 'rgba(255, 200, 100, 0.8)', borderWidth: 3, spanGaps: !1, fill: !1 }),
        isDrawAz && d.push({ label: 'Azimuth', data: g, backgroundColor: 'rgba(100, 200, 255, 0.8)', borderColor: 'rgba(100, 200, 255, 0.8)', borderWidth: 3, spanGaps: !1, fill: !1 }),
        isDrawEl && d.push({ label: 'Elevation', data: m, backgroundColor: 'rgba(100, 255, 200, 0.8)', borderColor: 'rgba(100, 255, 200, 0.8)', borderWidth: 3, spanGaps: !1, fill: !1 });
    })();
  var c = document.getElementById('satChart').getContext('2d');
  new Chart(c, { type: 'line', data: { labels: a, datasets: d }, options: { scales: { yAxes: [{ ticks: { beginAtZero: !0 } }] } } });
  !(function () {
    var e = !1,
      a = document.getElementById('satChart');
    a.getContext('2d');
    function o() {
      e || ((e = !0), (a.width = window.innerWidth), (a.height = window.innerHeight), (e = !1));
    }
    window.addEventListener('resize', o, !1), o();
  })();
}
(satellite.lookanglesInterval = 60),
  (satellite.calculateLookAngles = function (e, a, o, r) {
    var t;
    !(function () {
      if (void 0 === a) {
        if (!satellite.sensorSelected()) return void console.error('getlookangles2 requires a sensor!');
        a = satellite.currentSensor;
      } else {
        if (void 0 === a.obsminaz) return void console.error('sensor format incorrect');
        a.observerGd = { latitude: a.lat * DEG2RAD, longitude: a.lon * DEG2RAD, height: 1 * a.alt };
      }
      void 0 === e ? console.error('sat parameter required!') : (void 0 !== e.TLE1 && void 0 !== e.TLE2) || console.error('sat parameter invalid format!'),
        void 0 === t && (t = 0),
        void 0 === o && (o = 1),
        void 0 === satellite.isRiseSetLookangles && (satellite.isRiseSetLookangles = !1),
        void 0 === satellite.lookanglesInterval && (satellite.lookanglesInterval = 1);
    })();
    var s = 0,
      l = satellite.twoline2satrec(e.TLE1, e.TLE2),
      n = [];
    if (satellite.isRiseSetLookangles) {
      var i = satellite.lookanglesInterval;
      satellite.lookanglesInterval = 1;
    }
    void 0 === satellite.lookanglesLength && (satellite.lookanglesLength = 0.5);
    for (var g = 0; g < 24 * satellite.lookanglesLength * 60 * 60; g += satellite.lookanglesInterval) (s = 1e3 * g + t), n.length <= 15e3 && ((lookanglesRow = m(s, l)), 'undefined' != typeof lookanglesRow && n.push(lookanglesRow));
    function m(e, r) {
      var t = new Date();
      t.setTime(Number(Date.now()) + e);
      var s = d(t.getUTCFullYear(), t.getUTCMonth() + 1, t.getUTCDate(), t.getUTCHours(), t.getUTCMinutes(), t.getUTCSeconds());
      s += t.getUTCMilliseconds() * millisecondsPerDay;
      var l,
        n,
        i,
        g,
        m,
        b = satellite.gstime(s),
        c = (s - r.jdsatepoch) * minutesPerDay,
        u = satellite.sgp4(r, c);
      if (
        ((l = satellite.eciToEcf(u.position, b)),
        (i = (n = satellite.ecfToLookAngles(a.observerGd, l)).azimuth * RAD2DEG),
        (g = n.elevation * RAD2DEG),
        (m = n.rangeSat),
        a.obsminaz < a.obsmaxaz &&
          (!(i >= a.obsminaz && i <= a.obsmaxaz && g >= a.obsminel && g <= a.obsmaxel && m <= a.obsmaxrange && m >= a.obsminrange) ||
            (i >= a.obsminaz2 && i <= a.obsmaxaz2 && g >= a.obsminel2 && g <= a.obsmaxel2 && m <= a.obsmaxrange2 && m >= a.obsminrange2)))
      )
        return 1 == o ? { time: timeManager.dateFormat(t, 'isoDateTime', !0), rng: m, az: i, el: g } : 2 == o ? { time: timeManager.dateFormat(t, 'isoDateTime', !0), rng: null, az: null, el: null } : void 0;
      if (
        ((i >= a.obsminaz || i <= a.obsmaxaz) && g >= a.obsminel && g <= a.obsmaxel && m <= a.obsmaxrange && m >= a.obsminrange) ||
        ((i >= a.obsminaz2 || i <= a.obsmaxaz2) && g >= a.obsminel2 && g <= a.obsmaxel2 && m <= a.obsmaxrange2 && m >= a.obsminrange2)
      ) {
        if (satellite.isRiseSetLookangles) {
          var D = new Date();
          D.setTime(Number(Date.now()) + e - 1e3 * satellite.lookanglesInterval);
          var h = timeManager.jday(D.getUTCFullYear(), D.getUTCMonth() + 1, D.getUTCDate(), D.getUTCHours(), D.getUTCMinutes(), D.getUTCSeconds());
          h += D.getUTCMilliseconds() * millisecondsPerDay;
          var p,
            x,
            f,
            k,
            w,
            A = satellite.gstime(h),
            T = (h - r.jdsatepoch) * minutesPerDay,
            v = satellite.sgp4(r, T);
          return (
            (p = satellite.eciToEcf(v.position, A)),
            (f = (x = satellite.ecfToLookAngles(a.observerGd, p)).azimuth * RAD2DEG),
            (k = x.elevation * RAD2DEG),
            (w = x.rangeSat),
            !((i >= a.obsminaz || i <= a.obsmaxaz) && g >= a.obsminel && g <= a.obsmaxel && m <= a.obsmaxrange && m >= a.obsminrange) ||
            ((i >= a.obsminaz2 || i <= a.obsmaxaz2) && g >= a.obsminel2 && g <= a.obsmaxel2 && m <= a.obsmaxrange2 && m >= a.obsminrange2)
              ? { time: timeManager.dateFormat(t, 'isoDateTime', !0), rng: m, az: i, el: g }
              : (D.setTime(Number(Date.now()) + e - 1e3 * satellite.lookanglesInterval),
                (h = d(D.getUTCFullYear(), D.getUTCMonth() + 1, D.getUTCDate(), D.getUTCHours(), D.getUTCMinutes(), D.getUTCSeconds())),
                (h += D.getUTCMilliseconds() * millisecondsPerDay),
                (A = satellite.gstime(h)),
                (T = (h - r.jdsatepoch) * minutesPerDay),
                (v = satellite.sgp4(r, T)),
                (p = satellite.eciToEcf(v.position, A)),
                (f = (x = satellite.ecfToLookAngles(a.observerGd, p)).azimuth * RAD2DEG),
                (k = x.elevation * RAD2DEG),
                (w = x.rangeSat),
                !((f >= a.obsminaz || f <= a.obsmaxaz) && k >= a.obsminel && k <= a.obsmaxel && w <= a.obsmaxrange && w >= a.obsminrange) ||
                ((f >= a.obsminaz2 || f <= a.obsmaxaz2) && k >= a.obsminel2 && k <= a.obsmaxel2 && w <= a.obsmaxrange2 && w >= a.obsminrange2)
                  ? { time: timeManager.dateFormat(t, 'isoDateTime', !0), rng: m, az: i, el: g }
                  : 1 == o
                  ? { time: timeManager.dateFormat(t, 'isoDateTime', !0), rng: m, az: i, el: g }
                  : 2 == o
                  ? { time: timeManager.dateFormat(t, 'isoDateTime', !0), rng: null, az: null, el: null }
                  : void 0)
          );
        }
        return { time: timeManager.dateFormat(t, 'isoDateTime', !0), rng: m, az: i, el: g };
      }
      return 1 == o ? { time: timeManager.dateFormat(t, 'isoDateTime', !0), rng: m, az: i, el: g } : 2 == o ? { time: timeManager.dateFormat(t, 'isoDateTime', !0), rng: null, az: null, el: null } : void 0;
    }
    function d(e, a, o, r, t, s) {
      return e
        ? 367 * e - Math.floor(7 * (e + Math.floor((a + 9) / 12)) * 0.25) + Math.floor((275 * a) / 9) + o + 1721013.5 + ((s / 60 + t) / 60 + r) / 24
        : ((l = Date.now()), (jDayStart = new Date(l.getFullYear(), 0, 0)), (jDayDiff = l - jDayStart), Math.floor(jDayDiff / MILLISECONDS_PER_DAY));
      var l;
    }
    return satellite.isRiseSetLookangles && (satellite.lookanglesInterval = i), n;
  }),
  (function () {
    for (var e = window.location.search.substring(1).split('&'), a = 0; a < e.length; a++) {
      var o = e[a].split('=')[0],
        r = e[a].split('=')[1];
      switch (o) {
        case 'sat':
          requestInfo.sat = r;
          break;
        case 'type':
          'inc' == r && (isDrawInc = !0),
            'ap' == r && (isDrawApogee = !0),
            'pe' == r && (isDrawPerigee = !0),
            'e' == r && (isDrawEcc = !0),
            'per' == r && (isDrawPeriod = !0),
            'ra' == r && (isDrawRAAN = !0),
            'all' == r && ((isDrawApogee = !0), (isDrawPerigee = !0), (isDrawInc = !0), (isDrawEcc = !0), (isDrawRAAN = !0), (isDrawPeriod = !0)),
            'rng' == r && (isDrawRng = !0),
            'az' == r && (isDrawAz = !0),
            'el' == r && (isDrawEl = !0),
            'rae' == r && ((isDrawRng = !0), (isDrawAz = !0), (isDrawEl = !0));
          break;
        case 'sensor':
          'BLE' == r && (sensor = sensorManager.sensorList.BLE), 'CLR' == r && (sensor = sensorManager.sensorList.CLR), 'COD' == r && (sensor = sensorManager.sensorList.COD), 'FYL' == r && (sensor = sensorManager.sensorList.FYL);
          break;
        case 'lookanglesLength':
          satellite.lookanglesLength = parseFloat(r);
          break;
        case 'lookanglesInterval':
          satellite.lookanglesInterval = parseInt(r);
          break;
        case 'raeType':
          raeType = parseInt(r);
      }
    }
    loadJSON();
  })();
