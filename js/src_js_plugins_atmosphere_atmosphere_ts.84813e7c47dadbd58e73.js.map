{"version":3,"file":"src_js_plugins_atmosphere_atmosphere_ts.84813e7c47dadbd58e73.js","mappings":";;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4EAA4E,gDAAgD,6BAA6B,4BAA4B,mCAAmC,gCAAgC,4EAA4E,8EAA8E,8DAA8D,0CAA0C,kEAAkE,2DAA2D,qDAAqD,gEAAgE,wDAAwD,gDAAgD,oDAAoD,aAAa;AACr5B,+DAA+D,2BAA2B,yCAAyC,qCAAqC,oCAAoC,mCAAmC,oCAAoC,6BAA6B,mCAAmC,gFAAgF,yFAAyF,oDAAoD,wGAAwG,2DAA2D,aAAa;AAChuB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,wBAAwB;AAClD;AACA;AACA;AACA;AACA;AACA,8BAA8B,wBAAwB;AACtD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qDAAqD;AACrD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,uBAAuB;AACjD;AACA,8BAA8B,uBAAuB;AACrD,gEAAgE;AAChE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACqB","sources":["webpack://keeptrack.space/./src/js/plugins/atmosphere/atmosphere.ts"],"sourcesContent":["/* eslint-disable camelcase */\n/* eslint-disable no-useless-escape */\nvar Atmosphere = /** @class */ (function () {\n    function Atmosphere(gl, earth, settingsManager, glm) {\n        // Move to the code the creates the moon?\n        if (settingsManager.enableLimitedUI || settingsManager.isDrawLess)\n            return;\n        // Setup References to World\n        this.gl = gl;\n        this.earth = earth;\n        this.glm = glm;\n        this.settingsManager = settingsManager;\n        this.shaderCode = {\n            frag: \"#version 300 es\\n          precision highp float;        \\n    \\n          uniform vec3 u_lightDirection;\\n          in vec3 v_normal;\\n          in float v_dist;\\n  \\n          out vec4 fragColor;\\n    \\n          void main () {\\n              float sunAmount = max(dot(v_normal, u_lightDirection), 0.1);\\n              float darkAmount = max(dot(v_normal, -u_lightDirection), 0.0);\\n              float a4 = pow(1.3 - v_dist / 2.0, 1.1) * 2.0;\\n              float r = 1.0 - sunAmount;\\n              float g = max(1.0 - sunAmount, 0.75) - darkAmount;\\n              float b = max(sunAmount, 0.8) - darkAmount;\\n              float a1 = min(sunAmount, 0.8) * 2.0;\\n              float a2 = min(pow(darkAmount / 1.15, 2.0),0.2);\\n              float a3 = pow(v_dist,2.0) * -1.0 + 1.2;\\n              float a = min(a1 - a2, a3) * a4;\\n              fragColor    = vec4(vec3(r,g,b), a);\\n          }\\n          \",\n            vert: \"#version 300 es\\n          in vec3 position;\\n          in vec3 normal;\\n    \\n          uniform mat4 u_pMatrix;\\n          uniform mat4 u_camMatrix;\\n          uniform mat4 u_mvMatrix;\\n          uniform mat3 u_nMatrix;\\n    \\n          out vec3 v_normal;\\n          out float v_dist;\\n    \\n          void main(void) {\\n              vec4 position1 = u_camMatrix * u_mvMatrix * vec4(position, 1.0);\\n              vec4 position0 = u_camMatrix * u_mvMatrix * vec4(vec3(0.0,0.0,0.0), 1.0);\\n              gl_Position = u_pMatrix * position1;\\n              v_dist = distance(position0.xz,position1.xz) / \" + settingsManager.atmosphereSize + \".0;\\n              v_normal = normalize( u_nMatrix * normal );\\n          }\\n          \",\n        };\n        this.numLatSegs = 64;\n        this.numLonSegs = 64;\n        // We draw the moon way closer than it actually is because of depthBuffer issues\n        // Each draw loop we will scale the real position so it is consistent\n        this.drawPosition = [0, 0, 0];\n        // Create a gl program from the vert/frag shaders and geometry buffers\n        this.init(gl);\n        this.loaded = true;\n    }\n    Atmosphere.prototype.init = function (gl) {\n        var program = gl.createProgram();\n        program.vertShader = gl.createShader(gl.VERTEX_SHADER);\n        gl.shaderSource(program.vertShader, this.shaderCode.vert);\n        gl.compileShader(program.vertShader);\n        program.fragShader = gl.createShader(gl.FRAGMENT_SHADER);\n        gl.shaderSource(program.fragShader, this.shaderCode.frag);\n        gl.compileShader(program.fragShader);\n        gl.attachShader(program, program.vertShader);\n        gl.attachShader(program, program.fragShader);\n        gl.linkProgram(program);\n        if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {\n            var info = gl.getProgramInfoLog(program);\n            throw new Error('Could not compile WebGL program. \\n\\n' + info);\n        }\n        this.program = program;\n        // Assign Attributes\n        this.program.aVertexPosition = gl.getAttribLocation(this.program, 'position');\n        this.program.aVertexNormal = gl.getAttribLocation(this.program, 'normal');\n        this.program.u_pMatrix = gl.getUniformLocation(this.program, 'u_pMatrix');\n        this.program.u_camMatrix = gl.getUniformLocation(this.program, 'u_camMatrix');\n        this.program.u_mvMatrix = gl.getUniformLocation(this.program, 'u_mvMatrix');\n        this.program.u_nMatrix = gl.getUniformLocation(this.program, 'u_nMatrix');\n        this.program.u_lightDirection = gl.getUniformLocation(this.program, 'u_lightDirection');\n        // generate a uvsphere bottom up, CCW order\n        var vertPos = [];\n        var vertNorm = [];\n        var texCoord = [];\n        for (var lat = 0; lat <= this.numLatSegs; lat++) {\n            var latAngle = (Math.PI / this.numLatSegs) * lat - Math.PI / 2;\n            var diskRadius = Math.cos(Math.abs(latAngle));\n            var z = Math.sin(latAngle);\n            // console.log('LAT: ' + latAngle * RAD2DEG + ' , Z: ' + z);\n            // var i = 0;\n            for (var lon = 0; lon <= this.numLonSegs; lon++) {\n                // add an extra vertex for texture funness\n                var lonAngle = ((Math.PI * 2) / this.numLonSegs) * lon;\n                var x = Math.cos(lonAngle) * diskRadius;\n                var y = Math.sin(lonAngle) * diskRadius;\n                // console.log('i: ' + i + '    LON: ' + lonAngle * RAD2DEG + ' X: ' + x + ' Y: ' + y)\n                // mercator cylindrical projection (simple angle interpolation)\n                var v = 1 - lat / this.numLatSegs;\n                var u = 0.5 + lon / this.numLonSegs; // may need to change to move map\n                // console.log('u: ' + u + ' v: ' + v);\n                // normals: should just be a vector from center to point (aka the point itself!\n                vertPos.push(x * this.settingsManager.atmosphereSize);\n                vertPos.push(y * this.settingsManager.atmosphereSize);\n                vertPos.push(z * this.settingsManager.atmosphereSize);\n                texCoord.push(u);\n                texCoord.push(v);\n                vertNorm.push(x);\n                vertNorm.push(y);\n                vertNorm.push(z);\n                // i++;\n            }\n        }\n        // ok let's calculate vertex draw orders.... indiv triangles\n        var vertIndex = [];\n        for (var lat = 0; lat < this.numLatSegs; lat++) {\n            // this is for each QUAD, not each vertex, so <\n            for (var lon = 0; lon < this.numLonSegs; lon++) {\n                var blVert = lat * (this.numLonSegs + 1) + lon; // there's this.numLonSegs + 1 verts in each horizontal band\n                var brVert = blVert + 1;\n                var tlVert = (lat + 1) * (this.numLonSegs + 1) + lon;\n                var trVert = tlVert + 1;\n                // console.log('bl: ' + blVert + ' br: ' + brVert +  ' tl: ' + tlVert + ' tr: ' + trVert);\n                vertIndex.push(blVert);\n                vertIndex.push(brVert);\n                vertIndex.push(tlVert);\n                vertIndex.push(tlVert);\n                vertIndex.push(trVert);\n                vertIndex.push(brVert);\n            }\n        }\n        this.buffers = {};\n        this.buffers.vertCount = vertIndex.length;\n        this.buffers.vertPosBuf = gl.createBuffer();\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.buffers.vertPosBuf);\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertPos), gl.STATIC_DRAW);\n        this.buffers.vertNormBuf = gl.createBuffer();\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.buffers.vertNormBuf);\n        gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertNorm), gl.STATIC_DRAW);\n        this.buffers.vertIndexBuf = gl.createBuffer();\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.buffers.vertIndexBuf);\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, new Uint16Array(vertIndex), gl.STATIC_DRAW);\n        this.vao = gl.createVertexArray();\n        gl.bindVertexArray(this.vao);\n        // Select the vertex position buffer\n        // Enable the attribute\n        // Set the attribute\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.buffers.vertPosBuf);\n        gl.enableVertexAttribArray(this.program.aVertexPosition);\n        gl.vertexAttribPointer(this.program.aVertexPosition, 3, gl.FLOAT, false, 0, 0);\n        // Select the vertex normals buffer\n        // Enable the attribute\n        // Set the attribute\n        gl.bindBuffer(gl.ARRAY_BUFFER, this.buffers.vertNormBuf);\n        gl.enableVertexAttribArray(this.program.aVertexNormal);\n        gl.vertexAttribPointer(this.program.aVertexNormal, 3, gl.FLOAT, false, 0, 0);\n        // Select the vertex indicies buffer\n        gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.buffers.vertIndexBuf);\n        gl.bindVertexArray(null);\n    };\n    Atmosphere.prototype.draw = function (pMatrix, cameraManager) {\n        if (!this.loaded)\n            return;\n        var gl = this.gl;\n        // Enable blending and ignore depth test (especially on self)\n        gl.enable(gl.BLEND);\n        gl.disable(gl.DEPTH_TEST);\n        gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);\n        // Change to the atmosphere shader\n        gl.useProgram(this.program);\n        gl.bindVertexArray(this.vao);\n        // Set the uniforms\n        this.update(cameraManager.camPitch);\n        gl.uniformMatrix3fv(this.program.u_nMatrix, false, this.nMatrix);\n        gl.uniformMatrix4fv(this.program.u_mvMatrix, false, this.mvMatrix);\n        gl.uniformMatrix4fv(this.program.u_pMatrix, false, pMatrix);\n        gl.uniformMatrix4fv(this.program.u_camMatrix, false, cameraManager.camMatrix);\n        gl.uniform3fv(this.program.u_lightDirection, this.earth.lightDirection);\n        // Draw everythign to screen\n        gl.drawElements(gl.TRIANGLES, this.buffers.vertCount, gl.UNSIGNED_SHORT, 0);\n        gl.bindVertexArray(null);\n        // Disable blending and reeneable depth test\n        gl.disable(gl.BLEND);\n        gl.enable(gl.DEPTH_TEST);\n    };\n    Atmosphere.prototype.update = function (camPitch) {\n        // Start with an empyy model view matrix\n        this.mvMatrix = this.glm.mat4.create();\n        this.glm.mat4.identity(this.mvMatrix);\n        // Rotate model view matrix to prevent lines showing as camera rotates\n        this.glm.mat4.rotateY(this.mvMatrix, this.mvMatrix, 90 * (Math.PI / 180) - camPitch);\n        // Scale the atmosphere to 0,0,0 - needed?\n        this.glm.mat4.translate(this.mvMatrix, this.mvMatrix, [0, 0, 0]);\n        // Calculate normals\n        this.nMatrix = this.glm.mat3.create();\n        this.glm.mat3.normalFromMat4(this.nMatrix, this.mvMatrix);\n    };\n    return Atmosphere;\n}());\nexport { Atmosphere };\n"],"names":[],"sourceRoot":""}